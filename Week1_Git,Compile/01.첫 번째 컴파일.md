# 첫 번째 컴파일

![그림 : ls](.\images\20180318_140738.png)

`cd Learning_C` 명령어를 저장소 디렉터리로 이동한다.

그리고 `cd codes`로 저장소의 코드 예제 디렉터리로 이동한다.

`pwd` 명령어를 이용해 `codes` 디렉터리에 온 것을 확인한다.

![그림 : pwd의 결과 : Learning_C/codes](.\images\20180318_143039.png)

앞으로 `./hello` 처럼 명령을 실행하게 될텐데, `.`은 현재 디렉터리를 나타내는 말이다.
`ls .`을 입력하면 현재 디렉터리에 있는 파일을 볼 수 있다.

파일이 실행이 안될 경우, 이 입력이 정확한지 우선 확인한다.
(`/.hello`, `.hello`, `/hello` 처럼 오타가 나 있을 수 있다)

## Hello World

`gcc hello.c -o hello.exe` (이름은 상관없다. 윈도우와 다르게 확장자 없이 `hello`로만 해도 잘 작동한다)

로 소스를 컴파일하고,

`./hello.exe`

로 `Hello World!`가 출력된 것을 확인할 수 있다.

직접 `my_hello.c` 파일을 작성해보자.

```c
#include <stdio.h> // 출력을 위해 (STanDard Input/Output, stdio)

int main(int argc, char* argv[]){
    printf("Hello World!");

    return 0;
}
```

소스를 입력하였다면
`gcc my_hello.c -o my_hello`
을 실행하면 동일한 결과를 얻을 수 있다.

## argc, argv

`gcc echo.c -o echo.exe`를 실행한다.

이후 `./echo Hello!`를 입력하면 결과로 `Hello!`가 나오고, 어떤 값을 입력해도 그 값을 되돌려준다.

다음 예제로 argc, argv에 어떤 값이 들어 있는지 확인해보자.

```c
#include <stdio.h> // 출력을 위해 (STanDard Input/Output, stdio)

int main(int argc, char* argv[]){
    printf("%d", argc);
    printf("%s", argv); // 이 코드는 argv의 첫번째 값, 파일 이름만 가져올 것이다.

    return 0;
}
```

`gcc my_echo -o my_echo.exe`를 입력해 컴파일한다.

이 파일을 컴파일해 `my_echo 1 2`,`my_echo -option1 hello -option2 hi` 등으로 실행해보면 argc가 `매개변수`의 수를 저장하고 있는 것을 알 수 있다.

그럼 `매개변수`를 전부 

```c

```

## system 함수

* 주의 : system() 함수는 실전에서는 사용하지 않는 것이 좋음


## 주의사항 (지금은 무시할 것)

`Pull Request`는 해당 시점에 올린 `commit`뿐만 아니라 `Pull Request`를 신청한 이후의 `commit`까지 모두 Request에 올라간다.
`Pull Request` 이후 받아들여지기 전에 `굳이` 작업을 더 하고 싶다면 `branch`를 새로 생성해 작업한 뒤 `Pull Request`가 끝나면 해당 `branch`를 제거해야 한다.